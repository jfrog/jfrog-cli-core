package npm

import (
	"bufio"
	"fmt"
	"github.com/jfrog/build-info-go/build"
	biutils "github.com/jfrog/build-info-go/build/utils"
	"github.com/jfrog/gofrog/version"
	"github.com/jfrog/jfrog-cli-core/v2/artifactory/utils/npm"
	"github.com/jfrog/jfrog-cli-core/v2/utils/coreutils"
	"github.com/jfrog/jfrog-client-go/auth"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	commandUtils "github.com/jfrog/jfrog-cli-core/v2/artifactory/commands/utils"
	"github.com/jfrog/jfrog-cli-core/v2/artifactory/utils"
	"github.com/jfrog/jfrog-cli-core/v2/utils/config"
	"github.com/jfrog/jfrog-client-go/utils/errorutils"
	"github.com/jfrog/jfrog-client-go/utils/log"
)

const (
	npmrcFileName          = ".npmrc"
	npmrcBackupFileName    = "jfrog.npmrc.backup"
	minSupportedNpmVersion = "5.4.0"
)

type NpmCommand struct {
	CommonArgs
	cmdName        string
	jsonOutput     bool
	executablePath string
	// Function to be called to restore the user's old npmrc and delete the one we created.
	restoreNpmrcFunc func() error
	workingDirectory string
	// Npm registry as exposed by Artifactory.
	registry string
	// Npm token generated by Artifactory using the user's provided credentials.
	npmAuth             string
	authArtDetails      auth.ServiceDetails
	npmVersion          *version.Version
	internalCommandName string
	configFilePath      string
	collectBuildInfo    bool
	buildInfoModule     *build.NpmModule
}

func NewNpmCommand(cmdName string, collectBuildInfo bool) *NpmCommand {
	return &NpmCommand{
		cmdName:          cmdName,
		collectBuildInfo: collectBuildInfo,
	}
}

func NewNpmInstallCommand() *NpmCommand {
	return &NpmCommand{cmdName: "install", internalCommandName: "rt_npm_install"}
}

func NewNpmCiCommand() *NpmCommand {
	return &NpmCommand{cmdName: "ci", internalCommandName: "rt_npm_ci"}
}

func (ca *NpmCommand) CommandName() string {
	return ca.internalCommandName
}

func (ca *NpmCommand) SetConfigFilePath(configFilePath string) *NpmCommand {
	ca.configFilePath = configFilePath
	return ca
}

func (ca *NpmCommand) SetArgs(args []string) *NpmCommand {
	ca.npmArgs = args
	return ca
}

func (ca *NpmCommand) SetRepoConfig(conf *utils.RepositoryConfig) *NpmCommand {
	serverDetails, _ := conf.ServerDetails()
	ca.SetRepo(conf.TargetRepo()).SetServerDetails(serverDetails)
	return ca
}

func (ca *NpmCommand) SetServerDetails(serverDetails *config.ServerDetails) *NpmCommand {
	ca.serverDetails = serverDetails
	return ca
}

func (ca *NpmCommand) SetRepo(repo string) *NpmCommand {
	ca.repo = repo
	return ca
}

func (ca *NpmCommand) Init() error {
	// Read config file.
	log.Debug("Preparing to read the config file", ca.configFilePath)
	vConfig, err := utils.ReadConfigFile(ca.configFilePath, utils.YAML)
	if err != nil {
		return err
	}
	// Extract resolution params.
	resolverParams, err := utils.GetRepoConfigByPrefix(ca.configFilePath, utils.ProjectConfigResolverPrefix, vConfig)
	if err != nil {
		return err
	}
	_, _, _, filteredNpmArgs, buildConfiguration, err := commandUtils.ExtractNpmOptionsFromArgs(ca.npmArgs)
	if err != nil {
		return err
	}
	ca.SetRepoConfig(resolverParams).SetArgs(filteredNpmArgs).SetBuildConfiguration(buildConfiguration)
	return nil
}

func (ca *NpmCommand) SetBuildConfiguration(buildConfiguration *utils.BuildConfiguration) *NpmCommand {
	ca.buildConfiguration = buildConfiguration
	return ca
}

func (ca *NpmCommand) ServerDetails() (*config.ServerDetails, error) {
	return ca.serverDetails, nil
}

func (ca *NpmCommand) PreparePrerequisites(repo string) error {
	log.Debug("Preparing prerequisites...")
	var err error
	ca.npmVersion, ca.executablePath, err = biutils.GetNpmVersionAndExecPath(log.Logger)
	if err != nil {
		return err
	}
	if ca.npmVersion.Compare(minSupportedNpmVersion) > 0 {
		return errorutils.CheckErrorf(
			"JFrog CLI npm %s command requires npm client version "+minSupportedNpmVersion+" or higher. The Current version is: %s", ca.cmdName, ca.npmVersion.GetVersion())
	}

	if err := ca.setJsonOutput(); err != nil {
		return err
	}

	ca.workingDirectory, err = coreutils.GetWorkingDirectory()
	if err != nil {
		return err
	}
	log.Debug("Working directory set to:", ca.workingDirectory)
	if err = ca.setArtifactoryAuth(); err != nil {
		return err
	}

	ca.npmAuth, ca.registry, err = commandUtils.GetArtifactoryNpmRepoDetails(repo, &ca.authArtDetails)
	if err != nil {
		return err
	}

	return ca.setRestoreNpmrcFunc()
}

func (ca *NpmCommand) setRestoreNpmrcFunc() error {
	restoreNpmrcFunc, err := commandUtils.BackupFile(filepath.Join(ca.workingDirectory, npmrcFileName), filepath.Join(ca.workingDirectory, npmrcBackupFileName))
	if err != nil {
		return err
	}
	ca.restoreNpmrcFunc = func() error {
		if unsetEnvErr := os.Unsetenv(npmConfigAuthEnv); unsetEnvErr != nil {
			log.Warn("Couldn't unset", npmConfigAuthEnv)
		}
		return restoreNpmrcFunc()
	}
	return err
}

func (ca *NpmCommand) setArtifactoryAuth() error {
	authArtDetails, err := ca.serverDetails.CreateArtAuthConfig()
	if err != nil {
		return err
	}
	if authArtDetails.GetSshAuthHeaders() != nil {
		return errorutils.CheckErrorf("SSH authentication is not supported in this command")
	}
	ca.authArtDetails = authArtDetails
	return nil
}

func (ca *NpmCommand) setJsonOutput() error {
	jsonOutput, err := npm.ConfigGet(ca.npmArgs, "json", ca.executablePath)
	if err != nil {
		return err
	}

	// In case of --json=<not boolean>, the value of json is set to 'true', but the result from the command is not 'true'
	ca.jsonOutput = jsonOutput != "false"
	return nil
}

func (ca *NpmCommand) processConfigLine(configLine string) (filteredLine string, err error) {
	splitOption := strings.SplitN(configLine, "=", 2)
	key := strings.TrimSpace(splitOption[0])
	validLine := len(splitOption) == 2 && isValidKey(key)
	if !validLine {
		if strings.HasPrefix(splitOption[0], "@") {
			// Override scoped registries (@scope = xyz)
			return fmt.Sprintf("%s = %s\n", splitOption[0], ca.registry), nil
		}
		return
	}
	value := strings.TrimSpace(splitOption[1])
	if key == "_auth" {
		return "", ca.setNpmConfigAuthEnv(value)
	}
	if strings.HasPrefix(value, "[") && strings.HasSuffix(value, "]") {
		return addArrayConfigs(key, value), nil
	}

	return fmt.Sprintf("%s\n", configLine), err
}

func (ca *NpmCommand) setNpmConfigAuthEnv(value string) error {
	// Check if the npm version is bigger or equal to 9.3.1
	if ca.npmVersion.Compare(npmVersionForLegacyEnv) <= 0 {
		// Get registry name without the protocol name but including the '//'
		registryWithoutProtocolName := ca.registry[strings.Index(ca.registry, "://")+1:]
		// Set "npm_config_//<registry-url>:_auth" environment variable to allow authentication with Artifactory
		scopedRegistryEnv := fmt.Sprintf(npmConfigAuthEnv, registryWithoutProtocolName)
		return os.Setenv(scopedRegistryEnv, value)
	}
	// Set "npm_config__auth" environment variable to allow authentication with Artifactory when running postinstall scripts on subdirectories.
	// For Legacy NPM version < 9.3.1
	return os.Setenv(npmLegacyConfigAuthEnv, value)
}

func (ca *NpmCommand) prepareConfigData(data []byte) ([]byte, error) {
	var filteredConf []string
	configString := string(data) + "\n" + ca.npmAuth
	scanner := bufio.NewScanner(strings.NewReader(configString))
	for scanner.Scan() {
		currOption := scanner.Text()
		if currOption == "" {
			continue
		}
		filteredLine, err := ca.processConfigLine(currOption)
		if err != nil {
			return nil, errorutils.CheckError(err)
		}
		if filteredLine != "" {
			filteredConf = append(filteredConf, filteredLine)
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, errorutils.CheckError(err)
	}

	filteredConf = append(filteredConf, "json = ", strconv.FormatBool(ca.jsonOutput), "\n")
	filteredConf = append(filteredConf, "registry = ", ca.registry, "\n")
	return []byte(strings.Join(filteredConf, "")), nil
}

func (ca *NpmCommand) CreateTempNpmrc() error {
	log.Debug("Creating project .npmrc file.")
	data, err := npm.GetConfigList(ca.npmArgs, ca.executablePath)
	if err != nil {
		return err
	}
	configData, err := ca.prepareConfigData(data)
	if err != nil {
		return errorutils.CheckError(err)
	}

	if err = removeNpmrcIfExists(ca.workingDirectory); err != nil {
		return err
	}

	return errorutils.CheckError(os.WriteFile(filepath.Join(ca.workingDirectory, npmrcFileName), configData, 0600))
}

func (ca *NpmCommand) Run() (err error) {
	if err = ca.PreparePrerequisites(ca.repo); err != nil {
		return
	}
	defer func() {
		e := ca.restoreNpmrcFunc()
		if err == nil {
			err = e
		}
	}()
	if err = ca.CreateTempNpmrc(); err != nil {
		return
	}

	if err = ca.prepareBuildInfoModule(); err != nil {
		return
	}

	if err = ca.collectDependencies(); err != nil {
		return
	}
	log.Info(fmt.Sprintf("npm %s finished successfully.", ca.cmdName))
	return
}

func (ca *NpmCommand) prepareBuildInfoModule() error {
	var err error
	if ca.collectBuildInfo {
		ca.collectBuildInfo, err = ca.buildConfiguration.IsCollectBuildInfo()
		if err != nil {
			return err
		}
	}
	// Build-info should not be created when installing a single package (npm install <package name>).
	if ca.collectBuildInfo && len(filterFlags(ca.npmArgs)) > 0 {
		log.Info("Build-info dependencies collection is not supported for installations of single packages. Build-info creation is skipped.")
		ca.collectBuildInfo = false
	}
	buildName, err := ca.buildConfiguration.GetBuildName()
	if err != nil {
		return err
	}
	buildNumber, err := ca.buildConfiguration.GetBuildNumber()
	if err != nil {
		return err
	}
	buildInfoService := utils.CreateBuildInfoService()
	npmBuild, err := buildInfoService.GetOrCreateBuildWithProject(buildName, buildNumber, ca.buildConfiguration.GetProject())
	if err != nil {
		return errorutils.CheckError(err)
	}
	ca.buildInfoModule, err = npmBuild.AddNpmModule(ca.workingDirectory)
	if err != nil {
		return errorutils.CheckError(err)
	}
	ca.buildInfoModule.SetCollectBuildInfo(ca.collectBuildInfo)
	if ca.buildConfiguration.GetModule() != "" {
		ca.buildInfoModule.SetName(ca.buildConfiguration.GetModule())
	}
	return nil
}

func (ca *NpmCommand) collectDependencies() error {
	ca.buildInfoModule.SetNpmArgs(append([]string{ca.cmdName}, ca.npmArgs...))
	return errorutils.CheckError(ca.buildInfoModule.Build())
}

// Gets a config with value which is an array
func addArrayConfigs(key, arrayValue string) string {
	if arrayValue == "[]" {
		return ""
	}

	values := strings.TrimPrefix(strings.TrimSuffix(arrayValue, "]"), "[")
	valuesSlice := strings.Split(values, ",")
	var configArrayValues strings.Builder
	for _, val := range valuesSlice {
		configArrayValues.WriteString(fmt.Sprintf("%s[] = %s\n", key, val))
	}

	return configArrayValues.String()
}

func removeNpmrcIfExists(workingDirectory string) error {
	if _, err := os.Stat(filepath.Join(workingDirectory, npmrcFileName)); err != nil {
		// The file does not exist, nothing to do.
		if os.IsNotExist(err) {
			return nil
		}
		return errorutils.CheckError(err)
	}

	log.Debug("Removing Existing .npmrc file")
	return errorutils.CheckError(os.Remove(filepath.Join(workingDirectory, npmrcFileName)))
}

// To avoid writing configurations that are used by us
func isValidKey(key string) bool {
	return !strings.HasPrefix(key, "//") &&
		!strings.HasPrefix(key, ";") && // Comments
		!strings.HasPrefix(key, "@") && // Scoped configurations
		key != "registry" &&
		key != "metrics-registry" &&
		key != "json" // Handled separately because 'npm c ls' should run with json=false
}

func filterFlags(splitArgs []string) []string {
	var filteredArgs []string
	for _, arg := range splitArgs {
		if !strings.HasPrefix(arg, "-") {
			filteredArgs = append(filteredArgs, arg)
		}
	}
	return filteredArgs
}
