package components

import (
	"flag"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/urfave/cli"
)

func TestCreateCommandUsages(t *testing.T) {
	appNameSpace := "test-app"
	cmdName := "test-command"
	expectedPrefix := fmt.Sprintf("%s %s", appNameSpace, cmdName)

	optFlag := NewBoolFlag("dummyFlag", "")
	optStrFlag := NewStringFlag("optFlag", "", WithHelpValue("alias"))
	strFlag := NewStringFlag("flag", "", SetMandatory())

	override := []string{"usage override", "usage override 2", "usage override 3"}

	tests := []struct {
		name        string
		cmd         Command
		stringFlags map[string]StringFlag
		expected    []string
		expectErr   bool
	}{
		{
			name:     "no flags, no args",
			cmd:      Command{Name: cmdName},
			expected: []string{expectedPrefix},
		},
		{
			name:     "one optional flag, no args",
			cmd:      Command{Name: cmdName, Flags: []Flag{optFlag}},
			expected: []string{fmt.Sprintf("%s [command options]", expectedPrefix)},
		},
		{
			name:        "one mandatory flag, no args",
			cmd:         Command{Name: cmdName, Flags: []Flag{strFlag}},
			stringFlags: map[string]StringFlag{strFlag.Name: strFlag},
			expected:    []string{fmt.Sprintf("%s --%s=<value>", expectedPrefix, strFlag.Name)},
		},
		{
			name:        "multiple flags, no args",
			cmd:         Command{Name: cmdName, Flags: []Flag{strFlag, optStrFlag, optFlag}},
			stringFlags: map[string]StringFlag{strFlag.Name: strFlag, optStrFlag.Name: optStrFlag},
			expected:    []string{fmt.Sprintf("%s [command options] --%s=<value>", expectedPrefix, strFlag.Name)},
		},
		{
			name:     "no flags, mandatory args",
			cmd:      Command{Name: cmdName, Arguments: []Argument{{Name: "first argument"}, {Name: "second"}}},
			expected: []string{fmt.Sprintf("%s <%s> <%s>", expectedPrefix, "first argument", "second")},
		},
		{
			name:     "no flags, one optional arg",
			cmd:      Command{Name: cmdName, Arguments: []Argument{{Name: "first argument"}, {Name: "second", Optional: true}}},
			expected: []string{fmt.Sprintf("%s <%s> [%s]", expectedPrefix, "first argument", "second")},
		},
		{
			name: "with flag and args with replace",
			cmd: Command{
				Name:      cmdName,
				Flags:     []Flag{optStrFlag},
				Arguments: []Argument{{Name: "first argument"}, {Name: "second", ReplaceWithFlag: optStrFlag.Name}, {Name: "third", Optional: true, ReplaceWithFlag: optStrFlag.Name}},
			},
			stringFlags: map[string]StringFlag{optStrFlag.Name: optStrFlag},
			expected: []string{
				fmt.Sprintf("%s [command options] <%s> <%s> [%s]", expectedPrefix, "first argument", "second", "third"),
				fmt.Sprintf("%s --%s=<%s> <%s>", expectedPrefix, optStrFlag.Name, optStrFlag.HelpValue, "first argument"),
			},
		},
		{
			name:      "replacement error",
			cmd:       Command{Name: cmdName, Arguments: []Argument{{Name: "first argument"}, {Name: "second", ReplaceWithFlag: "not-exist"}}},
			expected:  []string{},
			expectErr: true,
		},
		{
			name: "with special usage cases",
			cmd: Command{
				Name:         cmdName,
				Flags:        []Flag{optStrFlag, optFlag},
				Arguments:    []Argument{{Name: "first argument"}, {Name: "second", ReplaceWithFlag: optStrFlag.Name}},
				UsageOptions: &UsageOptions{Usage: override},
			},
			stringFlags: map[string]StringFlag{optStrFlag.Name: optStrFlag},
			expected: append(override,
				fmt.Sprintf("%s [command options] <%s> <%s>", expectedPrefix, "first argument", "second"),
				fmt.Sprintf("%s [command options] --%s=<%s> <%s>", expectedPrefix, optStrFlag.Name, optStrFlag.HelpValue, "first argument"),
			),
		},
		{
			name: "with special usage cases, override",
			cmd: Command{
				Name:         "test-command",
				Flags:        []Flag{strFlag, optStrFlag, optFlag},
				Arguments:    []Argument{{Name: "first argument"}, {Name: "second", ReplaceWithFlag: optStrFlag.Name}},
				UsageOptions: &UsageOptions{Usage: override, ReplaceAutoGeneratedUsage: true},
			},
			stringFlags: map[string]StringFlag{optStrFlag.Name: optStrFlag, strFlag.Name: strFlag},
			expected:    override, //override is not expected to be changed upon using UsageOptions
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			usage, err := createCommandUsages(test.cmd, test.stringFlags, appNameSpace)
			if test.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.ElementsMatch(t, test.expected, usage)
			}
		})
	}
}

func TestCreateArgumentsSummary(t *testing.T) {
	cmd := Command{
		Arguments: []Argument{
			{
				Name:        "first argument",
				Description: "this is the first argument.",
			},
			{
				Name:        "second",
				Optional:    true,
				Description: "this is the second.",
			},
		},
	}
	expected :=
		`	first argument
		this is the first argument.

	second [Optional]
		this is the second.
`
	assert.Equal(t, createArgumentsSummary(cmd), expected)
}

func TestCreateEnvVarsSummary(t *testing.T) {
	cmd := Command{
		EnvVars: []EnvVar{
			{
				Name:        "FIRST_ENV",
				Default:     "15",
				Description: "This is the first env.",
			},
			{
				Name:        "NO_DEFAULT",
				Description: "This flag has no default.",
			},
			{
				Name:        "THIRD_ENV",
				Default:     "true",
				Description: "This is the third env.",
			},
		},
	}
	expected :=
		`	FIRST_ENV
		[Default: 15]
		This is the first env.

	NO_DEFAULT
		This flag has no default.

	THIRD_ENV
		[Default: true]
		This is the third env.`
	assert.Equal(t, createEnvVarsSummary(cmd), expected)
}

type invalidFlag struct {
	Name  string
	Usage string
}

func (f invalidFlag) GetName() string {
	return f.Name
}

func (f invalidFlag) GetDescription() string {
	return f.Usage
}

func (f invalidFlag) IsMandatory() bool {
	return false
}

func TestConvertByTypeFailWithInvalidFlag(t *testing.T) {
	invalid := invalidFlag{
		Name:  "invalid",
		Usage: "",
	}
	_, _, err := convertByType(invalid)
	assert.Error(t, err)
}

func TestConvertStringFlagDefault(t *testing.T) {
	f := NewStringFlag("string-flag", "This is how you use it.", WithStrDefaultValue("def"))
	converted, pointerF, err := convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Equal(t, pointerF, &f)

	expected := "--string-flag  \t[Default: def] This is how you use it."
	assert.Equal(t, converted.String(), expected)

	// Verify that when both Default and Mandatory are passed, only Default is shown.
	f.Mandatory = true
	converted, pointerF, err = convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Equal(t, pointerF, &f)
	assert.Equal(t, converted.String(), expected)
}

func TestConvertStringFlagMandatory(t *testing.T) {
	f := NewStringFlag("string-flag", "This is how you use it.", SetMandatory())
	converted, pointerF, err := convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Equal(t, pointerF, &f)

	assert.Equal(t, converted.String(), "--string-flag  \t[Mandatory] This is how you use it.")

	// Test optional.
	f.Mandatory = false
	converted, pointerF, err = convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Equal(t, pointerF, &f)
	assert.Equal(t, converted.String(), "--string-flag  \t[Optional] This is how you use it.")
}

func TestConvertBoolFlag(t *testing.T) {
	f := NewBoolFlag("bool-flag", "This is how you use it.", WithBoolDefaultValue(true))
	converted, pointerF, err := convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Nil(t, pointerF)
	assert.Equal(t, converted.String(), "--bool-flag  \t[Default: true] This is how you use it.")

	// Test optional.
	f.DefaultValue = false
	converted, pointerF, err = convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Nil(t, pointerF)
	assert.Equal(t, converted.String(), "--bool-flag  \t[Default: false] This is how you use it.")
}

func TestGetValueForStringFlag(t *testing.T) {
	f := NewStringFlag("string-flag", "This is how you use it.")
	flagSet := flag.NewFlagSet("test", flag.ContinueOnError)
	baseContext := cli.NewContext(nil, flagSet, nil)

	// Not received, no default or mandatory.
	finalValue, err := getValueForStringFlag(f, baseContext)
	assert.NoError(t, err)
	assert.Empty(t, finalValue)

	// Not received, no default but mandatory.
	f.Mandatory = true
	_, err = getValueForStringFlag(f, baseContext)
	assert.Error(t, err)

	// Not received, verify default is taken.
	f.DefaultValue = "default"
	finalValue, err = getValueForStringFlag(f, baseContext)
	assert.NoError(t, err)
	assert.Equal(t, finalValue, f.DefaultValue)

	// Received, verify default is ignored.
	expected := "value"
	flagSet.Var(DummyFlagValue{Value: expected}, f.Name, f.HelpValue)
	assert.NoError(t, baseContext.Set(f.Name, expected))
	finalValue, err = getValueForStringFlag(f, baseContext)
	assert.NoError(t, err)
	assert.Equal(t, finalValue, expected)
}

type DummyFlagValue struct {
	Value string
}

func (d DummyFlagValue) String() string {
	return d.Value
}

func (d DummyFlagValue) Set(value string) error {
	return nil
}
