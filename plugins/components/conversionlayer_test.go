package components

import (
	"fmt"
	"testing"

	"github.com/jfrog/jfrog-cli-core/v2/utils/coreutils"
	"github.com/stretchr/testify/assert"
)

func TestCreateCommandUsages(t *testing.T) {
	// TODO: Add support for arguments that can be either mandatory or changed to be used with a flag instead (spec flag for pattern arg).
	// TODO: More than one arg can be changed with a single flag (see move)
	// TODO: usage can be specified not base on args (const arg as cmd with their opts) (see ocstartbuild)
	// TODO: Arguments that can be optional
	// added support for optional arguments (see download) use [] and not <>.

	appNameSpace := "test-app"
	cmdName := "test-command"
	expectedPrefix := fmt.Sprintf("%s %s %s", coreutils.GetCliExecutableName(), appNameSpace, cmdName)

	optFlag := BoolFlag{Name: "dummyFlag"}
	optStrFlag := StringFlag{Name: "optFlag", ValueAlias: "alias"}
	strFlag := StringFlag{Name: "flag", Mandatory: true}

	override := []string{"usage override", "usage override 2", "usage override 3"}
	expectedOverride := []string{
		fmt.Sprintf("%s %s", expectedPrefix, "usage override"),
		fmt.Sprintf("%s %s", expectedPrefix, "usage override 2"),
		fmt.Sprintf("%s %s", expectedPrefix, "usage override 3"),
	}

	tests := []struct {
		name        string
		cmd         Command
		stringFlags map[string]StringFlag
		expected    []string
		expectErr   bool
	}{
		{
			name:     "no flags, no args",
			cmd:      Command{Name: cmdName},
			expected: []string{expectedPrefix},
		},
		{
			name:     "one optional flag, no args",
			cmd:      Command{Name: cmdName, Flags: []Flag{optFlag}},
			expected: []string{fmt.Sprintf("%s [command options]", expectedPrefix)},
		},
		{
			name:        "one mandatory flag, no args",
			cmd:         Command{Name: cmdName, Flags: []Flag{strFlag}},
			stringFlags: map[string]StringFlag{strFlag.Name: strFlag},
			expected:    []string{fmt.Sprintf("%s --%s=<value>", expectedPrefix, strFlag.Name)},
		},
		{
			name:        "multiple flags, no args",
			cmd:         Command{Name: cmdName, Flags: []Flag{strFlag, optStrFlag, optFlag}},
			stringFlags: map[string]StringFlag{strFlag.Name: strFlag, optStrFlag.Name: optStrFlag},
			expected:    []string{fmt.Sprintf("%s [command options] --%s=<value>", expectedPrefix, strFlag.Name)},
		},
		{
			name:     "no flags, mandatory args",
			cmd:      Command{Name: cmdName, Arguments: []Argument{{Name: "first argument"}, {Name: "second"}}},
			expected: []string{fmt.Sprintf("%s <%s> <%s>", expectedPrefix, "first argument", "second")},
		},
		{
			name:     "no flags, one optional arg",
			cmd:      Command{Name: cmdName, Arguments: []Argument{{Name: "first argument"}, {Name: "second", Optional: true}}},
			expected: []string{fmt.Sprintf("%s <%s> [%s]", expectedPrefix, "first argument", "second")},
		},
		{
			name: "with flag and args with replace",
			cmd: Command{
				Name:      cmdName,
				Flags:     []Flag{optStrFlag},
				Arguments: []Argument{{Name: "first argument"}, {Name: "second", ReplaceWithFlag: optStrFlag.Name}, {Name: "third", Optional: true, ReplaceWithFlag: optStrFlag.Name}},
			},
			stringFlags: map[string]StringFlag{optStrFlag.Name: optStrFlag},
			expected: []string{
				fmt.Sprintf("%s [command options] <%s> <%s> [%s]", expectedPrefix, "first argument", "second", "third"),
				fmt.Sprintf("%s --%s=<%s> <%s>", expectedPrefix, optStrFlag.Name, optStrFlag.ValueAlias, "first argument"),
			},
		},
		{
			name:      "replacement error",
			cmd:       Command{Name: cmdName, Arguments: []Argument{{Name: "first argument"}, {Name: "second", ReplaceWithFlag: "not-exist"}}},
			expected:  []string{},
			expectErr: true,
		},
		{
			name: "with special usage cases",
			cmd: Command{
				Name:         cmdName,
				Flags:        []Flag{optStrFlag, optFlag},
				Arguments:    []Argument{{Name: "first argument"}, {Name: "second", ReplaceWithFlag: optStrFlag.Name}},
				UsageOptions: &UsageOptions{Usage: override},
			},
			stringFlags: map[string]StringFlag{optStrFlag.Name: optStrFlag},
			expected: append(expectedOverride,
				fmt.Sprintf("%s [command options] <%s> <%s>", expectedPrefix, "first argument", "second"),
				fmt.Sprintf("%s [command options] --%s=<%s> <%s>", expectedPrefix, optStrFlag.Name, optStrFlag.ValueAlias, "first argument"),
			),
		},
		{
			name: "with special usage cases, override",
			cmd: Command{
				Name:         "test-command",
				Flags:        []Flag{strFlag, optStrFlag, optFlag},
				Arguments:    []Argument{{Name: "first argument"}, {Name: "second", ReplaceWithFlag: optStrFlag.Name}},
				UsageOptions: &UsageOptions{Usage: override, ReplaceAutoGeneratedUsage: true},
			},
			stringFlags: map[string]StringFlag{optStrFlag.Name: optStrFlag, strFlag.Name: strFlag},
			expected:    expectedOverride,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			usage, err := createCommandUsages(test.cmd, test.stringFlags, appNameSpace)
			if test.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.ElementsMatch(t, test.expected, usage)
			}
		})
	}
}

func TestCreateArgumentsSummary(t *testing.T) {
	cmd := Command{
		Arguments: []Argument{
			{
				Name:        "first argument",
				Description: "this is the first argument.",
			},
			{
				Name:        "second",
				Optional:    true,
				Description: "this is the second.",
			},
		},
	}
	expected :=
		`	first argument
		this is the first argument.

	second [Optional]
		this is the second.
`
	assert.Equal(t, createArgumentsSummary(cmd), expected)
}

func TestCreateEnvVarsSummary(t *testing.T) {
	cmd := Command{
		EnvVars: []EnvVar{
			{
				Name:        "FIRST_ENV",
				Default:     "15",
				Description: "This is the first env.",
			},
			{
				Name:        "NO_DEFAULT",
				Description: "This flag has no default.",
			},
			{
				Name:        "THIRD_ENV",
				Default:     "true",
				Description: "This is the third env.",
			},
		},
	}
	expected :=
		`	FIRST_ENV
		[Default: 15]
		This is the first env.

	NO_DEFAULT
		This flag has no default.

	THIRD_ENV
		[Default: true]
		This is the third env.`
	assert.Equal(t, createEnvVarsSummary(cmd), expected)
}

type invalidFlag struct {
	Name  string
	Usage string
}

func (f invalidFlag) GetName() string {
	return f.Name
}

func (f invalidFlag) GetDescription() string {
	return f.Usage
}

func (f invalidFlag) IsMandatory() bool {
	return false
}

func TestConvertByTypeFailWithInvalidFlag(t *testing.T) {
	invalid := invalidFlag{
		Name:  "invalid",
		Usage: "",
	}
	_, _, err := convertByType(invalid)
	assert.Error(t, err)
}

func TestConvertStringFlagDefault(t *testing.T) {
	f := StringFlag{
		Name:         "string-flag",
		Description:  "This is how you use it.",
		DefaultValue: "def",
	}
	converted, pointerF, err := convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Equal(t, pointerF, &f)

	expected := "--string-flag  \t[Default: def] This is how you use it."
	assert.Equal(t, converted.String(), expected)

	// Verify that when both Default and Mandatory are passed, only Default is shown.
	f.Mandatory = true
	converted, pointerF, err = convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Equal(t, pointerF, &f)
	assert.Equal(t, converted.String(), expected)
}

func TestConvertStringFlagMandatory(t *testing.T) {
	f := StringFlag{
		Name:        "string-flag",
		Description: "This is how you use it.",
		Mandatory:   true,
	}
	converted, pointerF, err := convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Equal(t, pointerF, &f)

	assert.Equal(t, converted.String(), "--string-flag  \t[Mandatory] This is how you use it.")

	// Test optional.
	f.Mandatory = false
	converted, pointerF, err = convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Equal(t, pointerF, &f)
	assert.Equal(t, converted.String(), "--string-flag  \t[Optional] This is how you use it.")
}

func TestConvertBoolFlag(t *testing.T) {
	f := BoolFlag{
		Name:         "bool-flag",
		Description:  "This is how you use it.",
		DefaultValue: true,
	}
	converted, pointerF, err := convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Nil(t, pointerF)
	assert.Equal(t, converted.String(), "--bool-flag  \t[Default: true] This is how you use it.")

	// Test optional.
	f.DefaultValue = false
	converted, pointerF, err = convertByType(f)
	if assert.NoError(t, err) {
		return
	}
	assert.Nil(t, pointerF)
	assert.Equal(t, converted.String(), "--bool-flag  \t[Default: false] This is how you use it.")
}

func TestGetValueForStringFlag(t *testing.T) {
	f := StringFlag{
		Name:        "string-flag",
		Description: "This is how you use it.",
		Mandatory:   false,
	}

	// Not received, no default or mandatory.
	finalValue, err := getValueForStringFlag(f, "")
	assert.NoError(t, err)
	assert.Empty(t, finalValue)

	// Not received, no default but mandatory.
	f.Mandatory = true
	_, err = getValueForStringFlag(f, "")
	assert.Error(t, err)

	// Not received, verify default is taken.
	f.DefaultValue = "default"
	finalValue, err = getValueForStringFlag(f, "")
	assert.NoError(t, err)
	assert.Equal(t, finalValue, f.DefaultValue)

	// Received, verify default is ignored.
	expected := "value"
	finalValue, err = getValueForStringFlag(f, expected)
	assert.NoError(t, err)
	assert.Equal(t, finalValue, expected)
}
